// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculatePoint
#pragma kernel CalculateNormal

struct WaveOptions{
	uint type;

	float2 position;

	float2 size;

	uint state;

	float stateTimeChange;

	float amplitude;

	float radius;

	float smooth;

	float waveNumber;

	float angularFrequency;

	float waveSpeed;

	float timeProgression;

	float time;

	float timeout;
};

struct FrameOptions{
	float time;
	uint nbWaves;
	float maxWaveHeight;
	uint lod;
	uint heigtMapRatio;
	float3 trash;
};

StructuredBuffer<WaveOptions> Impacts;
StructuredBuffer<FrameOptions> Options;
RWStructuredBuffer<float> Result;
RWTexture2D<float4> HeightNormalMap;

int lod;
float currentTime;
float wt;
float2 heightInfo;

void MakeImpact(uint i, float offsetMagnitude, float posAbs, float coeff, float constantWave){
	float theta = (Impacts[i].waveNumber * (offsetMagnitude / lod));
	float x = currentTime / (1 / (1 + Impacts[i].waveSpeed)) + posAbs;
	float timeProgress = Impacts[i].amplitude * sin(x) * lerp(1/x, 1, constantWave);
	float sinTheta = sin(theta* timeProgress) / exp(abs(posAbs) * Impacts[i].timeProgression);

	float heightAbs = abs(sinTheta);
	heightInfo = heightInfo + float2(sinTheta * (heightAbs/ coeff), (heightAbs / coeff));
}

void MakeZone(uint i, float offset, float coeff){
	float sinTheta = Impacts[i].amplitude * sin((Impacts[i].waveNumber * (offset / lod)) - wt);
	float heightAbs = abs(sinTheta);
	heightInfo = heightInfo + float2(sinTheta * (heightAbs/ coeff), (heightAbs / coeff));
}

void MakeVortex(uint i, float offsetMagnitude, float posAbs, float coeff){
	float theta = (Impacts[i].waveNumber * (1 / Impacts[i].radius) * (offsetMagnitude / lod));
	float x = currentTime / (1 / (1 + Impacts[i].waveSpeed)) - posAbs;
	float timeProgress = Impacts[i].amplitude * sin(x);
	float sinTheta = sin(theta * timeProgress);
	sinTheta += Impacts[i].amplitude * (exp((posAbs - Impacts[i].radius) / Impacts[i].smooth)  - 1);

	float heightAbs = abs(sinTheta);
	heightInfo = heightInfo + float2(sinTheta * (heightAbs/ coeff), (heightAbs / coeff));
}

[numthreads(32,32,1)]
void CalculatePoint (uint3 id : SV_DispatchThreadID)
{
	heightInfo = float2(0, 0);
	lod = Options[0].lod;

	int pointId = id.x * lod + id.y;

	for(uint i = 0; i < Options[0].nbWaves; i++){
		float2 offset = float2(Impacts[i].position.x - id.x, Impacts[i].position.y - id.y);
		
		currentTime = Impacts[i].time - Options[0].time;
		wt = Impacts[i].angularFrequency * currentTime;
		
		if(Impacts[i].type == 0){
			float offsetMagnitude = distance(float2(0, 0), offset);
			float posAbs = abs(offsetMagnitude);

			if(posAbs < Impacts[i].radius){
				heightInfo = float2(0, 1);
				break;
			}

			posAbs = posAbs - Impacts[i].radius;
			offsetMagnitude = posAbs * sign(offsetMagnitude);
			float coeff = (2 + posAbs);
			
			MakeImpact(i, offsetMagnitude, posAbs, coeff, 0);
		}
		else if(Impacts[i].type == 1){
			if((abs(offset.x) < Impacts[i].size.x) && (abs(offset.y) < Impacts[i].size.y)){
				heightInfo = float2(0, 1);
				break;
			}

			float newOffsetX = clamp(offset.x, - Impacts[i].size.x, Impacts[i].size.x);
			float newOffsetY = clamp(offset.y, - Impacts[i].size.y, Impacts[i].size.y);

			float offsetMagnitude = distance(float2(newOffsetX, newOffsetY), offset);
			float posAbs = abs(offsetMagnitude);
			float coeff = (2 + posAbs);

			MakeImpact(i, offsetMagnitude, posAbs, coeff, 1);
		}
		else if(Impacts[i].type == 2){
			float offsetMagnitude = distance(float2(0, 0), offset);
			float posAbs = abs(offsetMagnitude);
			float coeff = (2 + posAbs);

			MakeZone(i, offset.x, coeff);
		}
		else if(Impacts[i].type == 3){
			float offsetMagnitude = distance(float2(0, 0), offset);
			float posAbs = abs(offsetMagnitude);
			float coeff = (2 + posAbs);

			MakeZone(i, offsetMagnitude, coeff);
		}
		else if(Impacts[i].type == 4){
			float offsetMagnitude = distance(float2(0, 0), offset);
			float posAbs = abs(offsetMagnitude);
			float coeff = (2 + posAbs);

			if(posAbs < Impacts[i].radius){
				MakeVortex(i, offsetMagnitude, posAbs, coeff);
				break;
			}

			posAbs = posAbs - Impacts[i].radius;
			offsetMagnitude = posAbs * sign(offsetMagnitude);
			coeff = (2 + posAbs);
			
			MakeImpact(i, offsetMagnitude, -posAbs, coeff, 1);
		}
		
	}

	if(heightInfo.y == 0){
		Result[pointId] = 0;
	}
	else{
		Result[pointId] = heightInfo.x / heightInfo.y;
	}

	float textureHeight = (clamp(Result[pointId], -Options[0].maxWaveHeight, Options[0].maxWaveHeight) / Options[0].maxWaveHeight) + 0.5;

	for(uint l = (id.x * Options[0].heigtMapRatio); l < ((id.x + 1) * Options[0].heigtMapRatio); l++){
		for(uint k = (id.y * Options[0].heigtMapRatio); k < ((id.y + 1) * Options[0].heigtMapRatio); k++){
			HeightNormalMap[int2(l, k)] = float4(0, 0, 0, textureHeight);
		}
	}
}

RWStructuredBuffer<float3> Normales;

[numthreads(32,32,1)]
void CalculateNormal (uint3 id : SV_DispatchThreadID)
{
	int lod = Options[0].lod;

	int pointId = id.x * lod + id.y;

	int2 directions[4] = {int2(-1, 0), int2(1, 0), int2(0, -1), int2(0, 1)};

	int2 neighboursIds[4];
	float3 vertex[4];

	for(int i = 0; i < 4; i++){
		neighboursIds[i].x = min(max(0, id.x + directions[i].x), lod - 1);
		neighboursIds[i].y = min(max(0, id.y + directions[i].y), lod - 1);
	}

	float z1 = Result[neighboursIds[1].x * lod + neighboursIds[1].y] - Result[neighboursIds[0].x * lod + neighboursIds[0].y];
	float z2 = Result[neighboursIds[3].x * lod + neighboursIds[3].y] - Result[neighboursIds[2].x * lod + neighboursIds[2].y];

	Normales[pointId] = cross(float3(1, z1, 0), float3(0, z2, 1));

	for(uint l = (id.x * Options[0].heigtMapRatio); l < ((id.x + 1) * Options[0].heigtMapRatio); l++){
		for(uint k = (id.y * Options[0].heigtMapRatio); k < ((id.y + 1) * Options[0].heigtMapRatio); k++){
			HeightNormalMap[int2(l, k)] = float4(Normales[pointId], HeightNormalMap[int2(l, k)].a);
		}
	}
}