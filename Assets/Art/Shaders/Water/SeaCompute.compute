// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculatePoint
#pragma kernel CalculateNormal

struct WaveOptions{
	uint type;

	float2 position;

	float2 size;

	uint state;

	float stateTimeChange;

	float amplitude;

	float waveNumber;

	float angularFrequency;

	float waveSpeed;

	float timeProgression;

	float time;

	float timeout;

	float2 trash;
};

struct FrameOptions{
	float time;
	uint nbWaves;
	float maxWaveHeight;
	uint lod;
	uint heigtMapRatio;
	float3 trash;
};

StructuredBuffer<WaveOptions> Impacts;
StructuredBuffer<FrameOptions> Options;
RWStructuredBuffer<float> Result;
RWTexture2D<float4> HeightNormalMap;

int lod;
float currentTime;
float wt;
float sinTheta;
float heightAbs;
float2 heightInfo;

void MakeImpact(uint i, float offsetMagnitude, float posAbs, float coeff){
	float theta = (Impacts[i].waveNumber * (offsetMagnitude / lod));
	// float timeProgress = Impacts[i].amplitude - pow(currentTime / (1 / (1 + Impacts[i].waveSpeed)) + posAbs, 2);
	// sinTheta = sin(theta)  * max(0, timeProgress) / exp(posAbs * Impacts[i].timeProgression);
	float x = currentTime / (1 / (1 + Impacts[i].waveSpeed)) + posAbs;
	float timeProgress = Impacts[i].amplitude * sin(x) * (1/(x));
	sinTheta = sin(theta)  * timeProgress / exp(posAbs * Impacts[i].timeProgression);

	heightAbs = abs(sinTheta);
	heightInfo = heightInfo + float2(sinTheta * (heightAbs/ coeff), (heightAbs / coeff));
}

void MakeZone(uint i, float offset, float coeff){
	sinTheta = Impacts[i].amplitude * sin((Impacts[i].waveNumber * (offset / lod)) - wt);
	heightAbs = abs(sinTheta);
	heightInfo = heightInfo + float2(sinTheta * (heightAbs/ coeff), (heightAbs / coeff));
}

[numthreads(32,32,1)]
void CalculatePoint (uint3 id : SV_DispatchThreadID)
{
	heightInfo = float2(0, 0);
	lod = Options[0].lod;

	int pointId = id.x * lod + id.y;

	for(uint i = 0; i < Options[0].nbWaves; i++){
		float2 offset = float2(Impacts[i].position.x - id.x, Impacts[i].position.y - id.y);
		
		currentTime = Impacts[i].time - Options[0].time;
		wt = Impacts[i].angularFrequency * currentTime;

		sinTheta = 0;
		heightAbs = 0;

		float offsetMagnitude = distance(float2(0, 0), offset);
		float posAbs = abs(offsetMagnitude);
		float coeff = (2 + posAbs);
		
		if(Impacts[i].type == 0){
			MakeImpact(i, offsetMagnitude, posAbs, coeff);
		}
		else if(Impacts[i].type == 1){
			if((abs(offset.x) < Impacts[i].size.x) && (abs(offset.y) < Impacts[i].size.y)){
				heightAbs = 0;
				heightInfo = float2(0, 1);
				break;
			}

			float newOffsetX = clamp(offset.x, - Impacts[i].size.x, Impacts[i].size.x);
			float newOffsetY = clamp(offset.y, - Impacts[i].size.y, Impacts[i].size.y);

			float newMagnitude = distance(float2(newOffsetX, newOffsetY), offset);
			posAbs = abs(newMagnitude);
			coeff = (2 + posAbs);

			MakeImpact(i, newMagnitude, posAbs, coeff);
		}
		else if(Impacts[i].type == 2){
			MakeZone(i, offset.x, coeff);
		}
		else if(Impacts[i].type == 3){
			MakeZone(i, offsetMagnitude, coeff);
		}
		
	}

	if(heightInfo.y == 0){
		Result[pointId] = 0;
	}
	else{
		Result[pointId] = heightInfo.x / heightInfo.y;
	}

	float textureHeight = (clamp(Result[pointId], -Options[0].maxWaveHeight, Options[0].maxWaveHeight) / Options[0].maxWaveHeight) + 0.5;

	for(uint l = (id.x * Options[0].heigtMapRatio); l < ((id.x + 1) * Options[0].heigtMapRatio); l++){
		for(uint k = (id.y * Options[0].heigtMapRatio); k < ((id.y + 1) * Options[0].heigtMapRatio); k++){
			HeightNormalMap[int2(l, k)] = float4(0, 0, 0, textureHeight);
		}
	}
}

RWStructuredBuffer<float3> Normales;

[numthreads(32,32,1)]
void CalculateNormal (uint3 id : SV_DispatchThreadID)
{
	int lod = Options[0].lod;

	int pointId = id.x * lod + id.y;

	int2 directions[4] = {int2(-1, 0), int2(1, 0), int2(0, -1), int2(0, 1)};

	int2 neighboursIds[4];
	float3 vertex[4];

	for(int i = 0; i < 4; i++){
		neighboursIds[i].x = min(max(0, id.x + directions[i].x), lod - 1);
		neighboursIds[i].y = min(max(0, id.y + directions[i].y), lod - 1);
	}

	float z1 = Result[neighboursIds[1].x * lod + neighboursIds[1].y] - Result[neighboursIds[0].x * lod + neighboursIds[0].y];
	float z2 = Result[neighboursIds[3].x * lod + neighboursIds[3].y] - Result[neighboursIds[2].x * lod + neighboursIds[2].y];

	Normales[pointId] = cross(float3(1, z1, 0), float3(0, z2, 1));

	for(uint l = (id.x * Options[0].heigtMapRatio); l < ((id.x + 1) * Options[0].heigtMapRatio); l++){
		for(uint k = (id.y * Options[0].heigtMapRatio); k < ((id.y + 1) * Options[0].heigtMapRatio); k++){
			HeightNormalMap[int2(l, k)] = float4(Normales[pointId], HeightNormalMap[int2(l, k)].a);
		}
	}
}