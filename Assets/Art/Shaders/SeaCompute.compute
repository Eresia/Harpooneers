// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct WaveOptions{
	uint type;

	float2 position;

	float amplitude;

	float waveLength;

	float period;

	float waveNumber;

	float angularFrequency;

	float distanceDigress;

	float timeDigress;

	float time;

	float timeout;
};

struct FrameOptions{
	float time;
	uint nbWaves;
	float maxWaveHeight;
	uint lod;
	uint heigtMapRatio;
	float3 trash;
};

StructuredBuffer<WaveOptions> Impacts;
StructuredBuffer<FrameOptions> Options;
RWStructuredBuffer<float> Result;
RWTexture2D<float4> HeightMap;

[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float2 heightInfo = float2(0, 0);
	int lod = Options[0].lod;

	int pointId = id.x * lod + id.y;

	for(uint i = 0; i < Options[0].nbWaves; i++){
		float2 offset = float2(Impacts[i].position.x - id.x, Impacts[i].position.y - id.y);

		if((offset.x != 0) || (offset.y != 0)){
			float2 direction = float2(sign(offset.x), sign(offset.y));

			float2 posAbs = float2(abs(offset.x), abs(offset.y));

			float coeff = (posAbs.x + posAbs.y);
			
			float currentTime = Options[0].time - Impacts[i].time;
			float wt = Impacts[i].angularFrequency * currentTime;

			float theta = 0;
			
			if(Impacts[i].type == 0){
				float thetaX = (Impacts[i].waveNumber * (offset.x / lod)) - (wt * direction.x);
				float thetaY = (Impacts[i].waveNumber * (offset.y / lod)) - (wt * direction.y);

				float timeChange = 1 / exp(wt * Impacts[i].timeDigress);

				float xHeight = sin(thetaX) / exp(posAbs.x * Impacts[i].distanceDigress) * timeChange;
				float yHeight = sin(thetaY) / exp(posAbs.y * Impacts[i].distanceDigress) * timeChange;
				
				theta = (posAbs.x * xHeight + posAbs.y * yHeight) / (posAbs.x + posAbs.y);
			}
			else if(Impacts[i].type == 1){
				theta = sin((Impacts[i].waveNumber * (offset.x / lod)) - wt);
			}

			float finalHeight = Impacts[i].amplitude * theta;

			float heightAbs = abs(finalHeight);

			heightInfo = heightInfo + float2(finalHeight * (heightAbs/ coeff), (heightAbs / coeff));
		}

		
	}

	if(heightInfo.y == 0){
		Result[pointId] = 0;
	}
	else{
		Result[pointId] = heightInfo.x / heightInfo.y;
	}

	// id.x = lod - id.x;
	// id.y = lod - id.y;

	float textureHeight = (clamp(Result[pointId], -Options[0].maxWaveHeight, Options[0].maxWaveHeight) / Options[0].maxWaveHeight) + 0.5;

	for(uint l = (id.x * Options[0].heigtMapRatio); l < ((id.x + 1) * Options[0].heigtMapRatio); l++){
		for(uint k = (id.y * Options[0].heigtMapRatio); k < ((id.y + 1) * Options[0].heigtMapRatio); k++){
			HeightMap[int2(l, k)] = textureHeight;
		}
	}

	// int beginX = round(id.x * Options[0].heightMapRatio);
	// int endX = round((id.x + 1) * Options[0].heightMapRatio);

	// int beginY = round(id.y * Options[0].heightMapRatio);
	// int endY = round((id.y + 1) * Options[0].heightMapRatio);
	// for(int k = beginX; k < endX; k++){
	// 	for(int l = beginY; l < endY; l++){
	// 		float colorHeight = (clamp(Result[pointId], -Options[0].maxWaveHeight, Options[0].maxWaveHeight) / Options[0].maxWaveHeight) + 0.5;
	// 		HeightMap[int2(k, l)] = float4(colorHeight, colorHeight, colorHeight, 1);
	// 	}
	// }
}

